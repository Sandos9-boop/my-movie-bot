import asyncio, logging, re, urllib.parse, aiohttp, sqlite3, random, os
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, ReplyKeyboardMarkup, KeyboardButton
from telegram.ext import ApplicationBuilder, CommandHandler, CallbackQueryHandler, MessageHandler, filters, ContextTypes

# --- –ù–ê–°–¢–†–û–ô–ö–ò (–ö–ª—é—á–∏ –≤—à–∏—Ç—ã –¥–ª—è —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏ –≤ –æ–±–ª–∞–∫–µ) ---
BOT_TOKEN = "8262668090:AAE3UJkjIeEVPKotGV1HfGyfkWtNP9TDnaQ"
TMDB_API_KEY = "043f357a705bad3b63ba075408d399a2"

logging.basicConfig(format='%(asctime)s - %(levelname)s - %(message)s', level=logging.INFO)

# --- –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø –ë–ê–ó–´ ---
def init_db():
    conn = sqlite3.connect('movies.db')
    conn.execute('CREATE TABLE IF NOT EXISTS watchlist (user_id INTEGER, movie_id TEXT, title TEXT)')
    conn.commit()
    conn.close()

init_db()

# --- –§–£–ù–ö–¶–ò–Ø –ó–ê–ü–†–û–°–û–í –ö TMDB ---
async def fetch_tmdb(endpoint, params={}):
    p = {"api_key": TMDB_API_KEY, "language": "ru-RU"}
    p.update(params)
    async with aiohttp.ClientSession() as session:
        url = f"https://api.themoviedb.org/3/{endpoint}"
        try:
            async with session.get(url, params=p, timeout=10) as r:
                if r.status == 200:
                    return await r.json()
        except Exception as e:
            logging.error(f"–û—à–∏–±–∫–∞ TMDB: {e}")
        return {}

# --- –ö–û–ú–ê–ù–î–ê START ---
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    kbd = [
        [KeyboardButton("üî• –ü–æ–ø—É–ª—è—Ä–Ω—ã–µ"), KeyboardButton("üÜï –ù–æ–≤–∏–Ω–∫–∏")],
        [KeyboardButton("üìÖ –ü–æ –≥–æ–¥–∞–º"), KeyboardButton("üé≤ –†–∞–Ω–¥–æ–º")],
        [KeyboardButton("üìå –ú–æ–π —Å–ø–∏—Å–æ–∫")]
    ]
    await update.message.reply_text(
        "üé¨ *CineIntellect v51.9.4*\n–ë–æ—Ç —É—Å–ø–µ—à–Ω–æ –∑–∞–ø—É—â–µ–Ω –≤ –æ–±–ª–∞–∫–µ –∏ –≥–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ!", 
        reply_markup=ReplyKeyboardMarkup(kbd, resize_keyboard=True), 
        parse_mode="Markdown"
    )

# --- –û–ë–†–ê–ë–û–¢–ö–ê –¢–ï–ö–°–¢–ê ---
async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = update.message.text
    
    if text == "üî• –ü–æ–ø—É–ª—è—Ä–Ω—ã–µ":
        data = await fetch_tmdb("trending/movie/week")
        await send_list(update, "üî• –ü–æ–ø—É–ª—è—Ä–Ω—ã–µ —Ñ–∏–ª—å–º—ã –Ω–µ–¥–µ–ª–∏:", data.get('results', []), "movie")
    
    elif text == "üÜï –ù–æ–≤–∏–Ω–∫–∏":
        # –ó–∞–ø—Ä–∞—à–∏–≤–∞–µ–º –Ω–æ–≤–∏–Ω–∫–∏ —Å–µ—Ä–∏–∞–ª–æ–≤ (On The Air)
        data = await fetch_tmdb("tv/on_the_air")
        await send_list(update, "üÜï –ù–æ–≤–∏–Ω–∫–∏ —Å–µ—Ä–∏–∞–ª–æ–≤ (–≤ —ç—Ñ–∏—Ä–µ):", data.get('results', []), "tv")

    elif text == "üé≤ –†–∞–Ω–¥–æ–º":
        page = random.randint(1, 15)
        data = await fetch_tmdb("movie/top_rated", {"page": page})
        if data.get('results'):
            m = random.choice(data['results'])
            await show_card(update, context, m['id'], "movie")

    elif text == "üìÖ –ü–æ –≥–æ–¥–∞–º":
        kbd = [
            [InlineKeyboardButton("2024", callback_data="y:2024"), InlineKeyboardButton("2023", callback_data="y:2023")],
            [InlineKeyboardButton("2022", callback_data="y:2022"), InlineKeyboardButton("2015", callback_data="y:2015")]
        ]
        await update.message.reply_text("–í—ã–±–µ—Ä–∏—Ç–µ –≥–æ–¥ –¥–ª—è –ø–æ–∏—Å–∫–∞ —Ö–∏—Ç–æ–≤:", reply_markup=InlineKeyboardMarkup(kbd))

    elif text == "üìå –ú–æ–π —Å–ø–∏—Å–æ–∫":
        conn = sqlite3.connect('movies.db')
        res = conn.execute("SELECT movie_id, title FROM watchlist WHERE user_id = ?", (update.effective_user.id,)).fetchall()
        conn.close()
        if not res:
            await update.message.reply_text("–í–∞—à —Å–ø–∏—Å–æ–∫ –∏–∑–±—Ä–∞–Ω–Ω–æ–≥–æ –ø–æ–∫–∞ –ø—É—Å—Ç.")
        else:
            txt = "üìå *–í–∞—à —Å–ø–∏—Å–æ–∫:*\n\n" + "\n".join([f"‚Ä¢ {r[1]}" for r in res])
            await update.message.reply_text(txt, parse_mode="Markdown")
    
    else:
        # –ü–æ–∏—Å–∫ –ø–æ –ª—é–±–æ–º—É —Ç–µ–∫—Å—Ç—É (–Ω–∞–∑–≤–∞–Ω–∏–µ, –∞–∫—Ç–µ—Ä, —Ä–µ–∂–∏—Å—Å–µ—Ä)
        data = await fetch_tmdb("search/multi", {"query": text})
        await send_list(update, f"üîé –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø–æ –∑–∞–ø—Ä–æ—Å—É '{text}':", data.get('results', []))

# --- –û–¢–ü–†–ê–í–ö–ê –°–ü–ò–°–ö–ê –ö–ù–û–ü–ö–ê–ú–ò ---
async def send_list(update, title, items, force_type=None):
    kbd = []
    for i in items[:10]:
        name = i.get('title') or i.get('name')
        m_type = force_type or i.get('media_type', 'movie')
        if name and m_type:
            kbd.append([InlineKeyboardButton(f"üé¨ {name}", callback_data=f"{m_type}:{i['id']}")])
    
    if kbd:
        await update.message.reply_text(title, reply_markup=InlineKeyboardMarkup(kbd))
    else:
        await update.message.reply_text("üòî –ù–∏—á–µ–≥–æ –Ω–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –ø–æ —ç—Ç–æ–º—É –∑–∞–ø—Ä–æ—Å—É.")

# --- –ü–û–ö–ê–ó –ö–ê–†–¢–û–ß–ö–ò –§–ò–õ–¨–ú–ê ---
async def show_card(target, context, mid, m_type):
    m = await fetch_tmdb(f"{m_type}/{mid}")
    if not m: return
    
    title = m.get('title') or m.get('name')
    rating = m.get('vote_average', 0)
    date = m.get('release_date') or m.get('first_air_date') or "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ"
    overview = m.get('overview', '–û–ø–∏—Å–∞–Ω–∏–µ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç.')
    
    search_url = f"https://www.google.com/search?q={urllib.parse.quote(title + ' —Å–º–æ—Ç—Ä–µ—Ç—å –æ–Ω–ª–∞–π–Ω')}"
    
    caption = f"üé• *{title}*\n‚≠ê –†–µ–π—Ç–∏–Ω–≥: {rating:.1f} | üìÖ –î–∞—Ç–∞: {date}\n\n{overview[:600]}..."
    
    kbd = [
        [InlineKeyboardButton("üìå –í —Å–ø–∏—Å–æ–∫", callback_data=f"add:{mid}:{title[:20]}")],
        [InlineKeyboardButton("üçø –°–º–æ—Ç—Ä–µ—Ç—å –æ–Ω–ª–∞–π–Ω", url=search_url)]
    ]
    
    poster_path = m.get('poster_path')
    chat_id = target.message.chat_id if hasattr(target, 'message') else target.effective_chat.id
    
    try:
        if poster_path:
            poster_url = f"https://image.tmdb.org/t/p/w500{poster_path}"
            await context.bot.send_photo(chat_id, poster_url, caption=caption, reply_markup=InlineKeyboardMarkup(kbd), parse_mode="Markdown")
        else:
            await context.bot.send_message(chat_id, caption, reply_markup=InlineKeyboardMarkup(kbd), parse_mode="Markdown")
    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –∫–∞—Ä—Ç–æ—á–∫–∏: {e}")

# --- –û–ë–†–ê–ë–û–¢–ö–ê –ù–ê–ñ–ê–¢–ò–ô –ö–ù–û–ü–û–ö ---
async def callback_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    q = update.callback_query
    await q.answer()
    
    if q.data.startswith("y:"):
        year = q.data.split(":")[1]
        data = await fetch_tmdb("discover/movie", {"primary_release_year": year, "sort_by": "popularity.desc"})
        items = data.get('results', [])[:10]
        kbd = [[InlineKeyboardButton(f"üé¨ {i['title']}", callback_data=f"movie:{i['id']}")] for i in items]
        await q.message.edit_text(f"üìÖ –°–∞–º—ã–µ –ø–æ–ø—É–ª—è—Ä–Ω—ã–µ —Ñ–∏–ª—å–º—ã {year} –≥–æ–¥–∞:", reply_markup=InlineKeyboardMarkup(kbd))
    
    elif q.data.startswith("add:"):
        _, mid, title = q.data.split(":", 2)
        conn = sqlite3.connect('movies.db')
        conn.execute("INSERT INTO watchlist VALUES (?, ?, ?)", (q.from_user.id, mid, title))
        conn.commit()
        conn.close()
        await context.bot.send_message(q.message.chat_id, f"‚úÖ –î–æ–±–∞–≤–ª–µ–Ω–æ –≤ —Å–ø–∏—Å–æ–∫: {title}")
        
    elif ":" in q.data:
        m_type, mid = q.data.split(":")
        await show_card(q, context, mid, m_type)

# --- –ó–ê–ü–£–°–ö ---
if __name__ == "__main__":
    app = ApplicationBuilder().token(BOT_TOKEN).build()
    
    app.add_handler(CommandHandler("start", start))
    app.add_handler(CallbackQueryHandler(callback_handler))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))
    
    print("üöÄ –ë–û–¢ v51.9.4 –ó–ê–ü–£–©–ï–ù! –ù–∞–∂–º–∏—Ç–µ /start –≤ Telegram.")
    app.run_polling()